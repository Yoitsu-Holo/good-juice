// 定义项目 API 的 proto 文件 可以同时描述 gRPC 和 HTTP API
// protobuf 文件参考:
//  - https://developers.google.com/protocol-buffers/

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.24.4
// source: helloworld/v1/api.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	UserBasic_UserLogin_FullMethodName      = "/v1.UserBasic/UserLogin"
	UserBasic_UserRegister_FullMethodName   = "/v1.UserBasic/UserRegister"
	UserBasic_UpdateUserInfo_FullMethodName = "/v1.UserBasic/UpdateUserInfo"
	UserBasic_GetUserInfo_FullMethodName    = "/v1.UserBasic/GetUserInfo"
	UserBasic_SearchUserList_FullMethodName = "/v1.UserBasic/SearchUserList"
)

// UserBasicClient is the client API for UserBasic service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserBasicClient interface {
	// 用户登陆
	UserLogin(ctx context.Context, in *UserLoginRequest, opts ...grpc.CallOption) (*UserLoginResponse, error)
	// 用户注册
	UserRegister(ctx context.Context, in *UserRegisterRequest, opts ...grpc.CallOption) (*UserRegisterResponse, error)
	// 用户信息更新接口
	UpdateUserInfo(ctx context.Context, in *UserUpdateInfoRequest, opts ...grpc.CallOption) (*UserUpdateInfoResponse, error)
	// 获取用户信息
	GetUserInfo(ctx context.Context, in *GetUserInfoRequest, opts ...grpc.CallOption) (*UserInfoResponse, error)
	// 搜索用户
	SearchUserList(ctx context.Context, in *SeaechUserListRequest, opts ...grpc.CallOption) (*UserListResponse, error)
}

type userBasicClient struct {
	cc grpc.ClientConnInterface
}

func NewUserBasicClient(cc grpc.ClientConnInterface) UserBasicClient {
	return &userBasicClient{cc}
}

func (c *userBasicClient) UserLogin(ctx context.Context, in *UserLoginRequest, opts ...grpc.CallOption) (*UserLoginResponse, error) {
	out := new(UserLoginResponse)
	err := c.cc.Invoke(ctx, UserBasic_UserLogin_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userBasicClient) UserRegister(ctx context.Context, in *UserRegisterRequest, opts ...grpc.CallOption) (*UserRegisterResponse, error) {
	out := new(UserRegisterResponse)
	err := c.cc.Invoke(ctx, UserBasic_UserRegister_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userBasicClient) UpdateUserInfo(ctx context.Context, in *UserUpdateInfoRequest, opts ...grpc.CallOption) (*UserUpdateInfoResponse, error) {
	out := new(UserUpdateInfoResponse)
	err := c.cc.Invoke(ctx, UserBasic_UpdateUserInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userBasicClient) GetUserInfo(ctx context.Context, in *GetUserInfoRequest, opts ...grpc.CallOption) (*UserInfoResponse, error) {
	out := new(UserInfoResponse)
	err := c.cc.Invoke(ctx, UserBasic_GetUserInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userBasicClient) SearchUserList(ctx context.Context, in *SeaechUserListRequest, opts ...grpc.CallOption) (*UserListResponse, error) {
	out := new(UserListResponse)
	err := c.cc.Invoke(ctx, UserBasic_SearchUserList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserBasicServer is the server API for UserBasic service.
// All implementations must embed UnimplementedUserBasicServer
// for forward compatibility
type UserBasicServer interface {
	// 用户登陆
	UserLogin(context.Context, *UserLoginRequest) (*UserLoginResponse, error)
	// 用户注册
	UserRegister(context.Context, *UserRegisterRequest) (*UserRegisterResponse, error)
	// 用户信息更新接口
	UpdateUserInfo(context.Context, *UserUpdateInfoRequest) (*UserUpdateInfoResponse, error)
	// 获取用户信息
	GetUserInfo(context.Context, *GetUserInfoRequest) (*UserInfoResponse, error)
	// 搜索用户
	SearchUserList(context.Context, *SeaechUserListRequest) (*UserListResponse, error)
	mustEmbedUnimplementedUserBasicServer()
}

// UnimplementedUserBasicServer must be embedded to have forward compatible implementations.
type UnimplementedUserBasicServer struct {
}

func (UnimplementedUserBasicServer) UserLogin(context.Context, *UserLoginRequest) (*UserLoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserLogin not implemented")
}
func (UnimplementedUserBasicServer) UserRegister(context.Context, *UserRegisterRequest) (*UserRegisterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRegister not implemented")
}
func (UnimplementedUserBasicServer) UpdateUserInfo(context.Context, *UserUpdateInfoRequest) (*UserUpdateInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserInfo not implemented")
}
func (UnimplementedUserBasicServer) GetUserInfo(context.Context, *GetUserInfoRequest) (*UserInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserInfo not implemented")
}
func (UnimplementedUserBasicServer) SearchUserList(context.Context, *SeaechUserListRequest) (*UserListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchUserList not implemented")
}
func (UnimplementedUserBasicServer) mustEmbedUnimplementedUserBasicServer() {}

// UnsafeUserBasicServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserBasicServer will
// result in compilation errors.
type UnsafeUserBasicServer interface {
	mustEmbedUnimplementedUserBasicServer()
}

func RegisterUserBasicServer(s grpc.ServiceRegistrar, srv UserBasicServer) {
	s.RegisterService(&UserBasic_ServiceDesc, srv)
}

func _UserBasic_UserLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserLoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserBasicServer).UserLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserBasic_UserLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserBasicServer).UserLogin(ctx, req.(*UserLoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserBasic_UserRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserBasicServer).UserRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserBasic_UserRegister_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserBasicServer).UserRegister(ctx, req.(*UserRegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserBasic_UpdateUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserUpdateInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserBasicServer).UpdateUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserBasic_UpdateUserInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserBasicServer).UpdateUserInfo(ctx, req.(*UserUpdateInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserBasic_GetUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserBasicServer).GetUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserBasic_GetUserInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserBasicServer).GetUserInfo(ctx, req.(*GetUserInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserBasic_SearchUserList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SeaechUserListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserBasicServer).SearchUserList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserBasic_SearchUserList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserBasicServer).SearchUserList(ctx, req.(*SeaechUserListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserBasic_ServiceDesc is the grpc.ServiceDesc for UserBasic service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserBasic_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "v1.UserBasic",
	HandlerType: (*UserBasicServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UserLogin",
			Handler:    _UserBasic_UserLogin_Handler,
		},
		{
			MethodName: "UserRegister",
			Handler:    _UserBasic_UserRegister_Handler,
		},
		{
			MethodName: "UpdateUserInfo",
			Handler:    _UserBasic_UpdateUserInfo_Handler,
		},
		{
			MethodName: "GetUserInfo",
			Handler:    _UserBasic_GetUserInfo_Handler,
		},
		{
			MethodName: "SearchUserList",
			Handler:    _UserBasic_SearchUserList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "helloworld/v1/api.proto",
}

const (
	VideoManage_PublishVideo_FullMethodName = "/v1.VideoManage/PublishVideo"
	VideoManage_DeleteVideo_FullMethodName  = "/v1.VideoManage/DeleteVideo"
)

// VideoManageClient is the client API for VideoManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VideoManageClient interface {
	// 发布视频
	PublishVideo(ctx context.Context, in *PublishVideoRequest, opts ...grpc.CallOption) (*PublishVideoResponse, error)
	// 删除视频
	DeleteVideo(ctx context.Context, in *DeleteVideoRequest, opts ...grpc.CallOption) (*DeleteVideoResponse, error)
}

type videoManageClient struct {
	cc grpc.ClientConnInterface
}

func NewVideoManageClient(cc grpc.ClientConnInterface) VideoManageClient {
	return &videoManageClient{cc}
}

func (c *videoManageClient) PublishVideo(ctx context.Context, in *PublishVideoRequest, opts ...grpc.CallOption) (*PublishVideoResponse, error) {
	out := new(PublishVideoResponse)
	err := c.cc.Invoke(ctx, VideoManage_PublishVideo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoManageClient) DeleteVideo(ctx context.Context, in *DeleteVideoRequest, opts ...grpc.CallOption) (*DeleteVideoResponse, error) {
	out := new(DeleteVideoResponse)
	err := c.cc.Invoke(ctx, VideoManage_DeleteVideo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VideoManageServer is the server API for VideoManage service.
// All implementations must embed UnimplementedVideoManageServer
// for forward compatibility
type VideoManageServer interface {
	// 发布视频
	PublishVideo(context.Context, *PublishVideoRequest) (*PublishVideoResponse, error)
	// 删除视频
	DeleteVideo(context.Context, *DeleteVideoRequest) (*DeleteVideoResponse, error)
	mustEmbedUnimplementedVideoManageServer()
}

// UnimplementedVideoManageServer must be embedded to have forward compatible implementations.
type UnimplementedVideoManageServer struct {
}

func (UnimplementedVideoManageServer) PublishVideo(context.Context, *PublishVideoRequest) (*PublishVideoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishVideo not implemented")
}
func (UnimplementedVideoManageServer) DeleteVideo(context.Context, *DeleteVideoRequest) (*DeleteVideoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteVideo not implemented")
}
func (UnimplementedVideoManageServer) mustEmbedUnimplementedVideoManageServer() {}

// UnsafeVideoManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VideoManageServer will
// result in compilation errors.
type UnsafeVideoManageServer interface {
	mustEmbedUnimplementedVideoManageServer()
}

func RegisterVideoManageServer(s grpc.ServiceRegistrar, srv VideoManageServer) {
	s.RegisterService(&VideoManage_ServiceDesc, srv)
}

func _VideoManage_PublishVideo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishVideoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoManageServer).PublishVideo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoManage_PublishVideo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoManageServer).PublishVideo(ctx, req.(*PublishVideoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoManage_DeleteVideo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVideoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoManageServer).DeleteVideo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoManage_DeleteVideo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoManageServer).DeleteVideo(ctx, req.(*DeleteVideoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VideoManage_ServiceDesc is the grpc.ServiceDesc for VideoManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VideoManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "v1.VideoManage",
	HandlerType: (*VideoManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PublishVideo",
			Handler:    _VideoManage_PublishVideo_Handler,
		},
		{
			MethodName: "DeleteVideo",
			Handler:    _VideoManage_DeleteVideo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "helloworld/v1/api.proto",
}

const (
	VideoInteract_SetLike_FullMethodName         = "/v1.VideoInteract/SetLike"
	VideoInteract_GetLikeList_FullMethodName     = "/v1.VideoInteract/GetLikeList"
	VideoInteract_SetSave_FullMethodName         = "/v1.VideoInteract/SetSave"
	VideoInteract_GetSaveList_FullMethodName     = "/v1.VideoInteract/GetSaveList"
	VideoInteract_PublishComment_FullMethodName  = "/v1.VideoInteract/PublishComment"
	VideoInteract_DeleteComment_FullMethodName   = "/v1.VideoInteract/DeleteComment"
	VideoInteract_GetCommentsList_FullMethodName = "/v1.VideoInteract/GetCommentsList"
)

// VideoInteractClient is the client API for VideoInteract service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VideoInteractClient interface {
	// 视频点赞
	SetLike(ctx context.Context, in *SetLikeRequest, opts ...grpc.CallOption) (*LikeResponse, error)
	GetLikeList(ctx context.Context, in *GetLikeListRequest, opts ...grpc.CallOption) (*LikeListResponse, error)
	// 视频收藏
	SetSave(ctx context.Context, in *SetSaveRequest, opts ...grpc.CallOption) (*SaveResponse, error)
	GetSaveList(ctx context.Context, in *GetSaveListRequest, opts ...grpc.CallOption) (*SaveListResponse, error)
	// 视频评论
	PublishComment(ctx context.Context, in *PublishCommentRequest, opts ...grpc.CallOption) (*PublishCommentResponse, error)
	DeleteComment(ctx context.Context, in *DeleteCommentRequest, opts ...grpc.CallOption) (*DeleteCommentResponse, error)
	GetCommentsList(ctx context.Context, in *GetCommentListRequest, opts ...grpc.CallOption) (*CommentListResponse, error)
}

type videoInteractClient struct {
	cc grpc.ClientConnInterface
}

func NewVideoInteractClient(cc grpc.ClientConnInterface) VideoInteractClient {
	return &videoInteractClient{cc}
}

func (c *videoInteractClient) SetLike(ctx context.Context, in *SetLikeRequest, opts ...grpc.CallOption) (*LikeResponse, error) {
	out := new(LikeResponse)
	err := c.cc.Invoke(ctx, VideoInteract_SetLike_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoInteractClient) GetLikeList(ctx context.Context, in *GetLikeListRequest, opts ...grpc.CallOption) (*LikeListResponse, error) {
	out := new(LikeListResponse)
	err := c.cc.Invoke(ctx, VideoInteract_GetLikeList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoInteractClient) SetSave(ctx context.Context, in *SetSaveRequest, opts ...grpc.CallOption) (*SaveResponse, error) {
	out := new(SaveResponse)
	err := c.cc.Invoke(ctx, VideoInteract_SetSave_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoInteractClient) GetSaveList(ctx context.Context, in *GetSaveListRequest, opts ...grpc.CallOption) (*SaveListResponse, error) {
	out := new(SaveListResponse)
	err := c.cc.Invoke(ctx, VideoInteract_GetSaveList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoInteractClient) PublishComment(ctx context.Context, in *PublishCommentRequest, opts ...grpc.CallOption) (*PublishCommentResponse, error) {
	out := new(PublishCommentResponse)
	err := c.cc.Invoke(ctx, VideoInteract_PublishComment_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoInteractClient) DeleteComment(ctx context.Context, in *DeleteCommentRequest, opts ...grpc.CallOption) (*DeleteCommentResponse, error) {
	out := new(DeleteCommentResponse)
	err := c.cc.Invoke(ctx, VideoInteract_DeleteComment_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoInteractClient) GetCommentsList(ctx context.Context, in *GetCommentListRequest, opts ...grpc.CallOption) (*CommentListResponse, error) {
	out := new(CommentListResponse)
	err := c.cc.Invoke(ctx, VideoInteract_GetCommentsList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VideoInteractServer is the server API for VideoInteract service.
// All implementations must embed UnimplementedVideoInteractServer
// for forward compatibility
type VideoInteractServer interface {
	// 视频点赞
	SetLike(context.Context, *SetLikeRequest) (*LikeResponse, error)
	GetLikeList(context.Context, *GetLikeListRequest) (*LikeListResponse, error)
	// 视频收藏
	SetSave(context.Context, *SetSaveRequest) (*SaveResponse, error)
	GetSaveList(context.Context, *GetSaveListRequest) (*SaveListResponse, error)
	// 视频评论
	PublishComment(context.Context, *PublishCommentRequest) (*PublishCommentResponse, error)
	DeleteComment(context.Context, *DeleteCommentRequest) (*DeleteCommentResponse, error)
	GetCommentsList(context.Context, *GetCommentListRequest) (*CommentListResponse, error)
	mustEmbedUnimplementedVideoInteractServer()
}

// UnimplementedVideoInteractServer must be embedded to have forward compatible implementations.
type UnimplementedVideoInteractServer struct {
}

func (UnimplementedVideoInteractServer) SetLike(context.Context, *SetLikeRequest) (*LikeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLike not implemented")
}
func (UnimplementedVideoInteractServer) GetLikeList(context.Context, *GetLikeListRequest) (*LikeListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLikeList not implemented")
}
func (UnimplementedVideoInteractServer) SetSave(context.Context, *SetSaveRequest) (*SaveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSave not implemented")
}
func (UnimplementedVideoInteractServer) GetSaveList(context.Context, *GetSaveListRequest) (*SaveListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSaveList not implemented")
}
func (UnimplementedVideoInteractServer) PublishComment(context.Context, *PublishCommentRequest) (*PublishCommentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishComment not implemented")
}
func (UnimplementedVideoInteractServer) DeleteComment(context.Context, *DeleteCommentRequest) (*DeleteCommentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteComment not implemented")
}
func (UnimplementedVideoInteractServer) GetCommentsList(context.Context, *GetCommentListRequest) (*CommentListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCommentsList not implemented")
}
func (UnimplementedVideoInteractServer) mustEmbedUnimplementedVideoInteractServer() {}

// UnsafeVideoInteractServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VideoInteractServer will
// result in compilation errors.
type UnsafeVideoInteractServer interface {
	mustEmbedUnimplementedVideoInteractServer()
}

func RegisterVideoInteractServer(s grpc.ServiceRegistrar, srv VideoInteractServer) {
	s.RegisterService(&VideoInteract_ServiceDesc, srv)
}

func _VideoInteract_SetLike_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLikeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoInteractServer).SetLike(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoInteract_SetLike_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoInteractServer).SetLike(ctx, req.(*SetLikeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoInteract_GetLikeList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLikeListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoInteractServer).GetLikeList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoInteract_GetLikeList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoInteractServer).GetLikeList(ctx, req.(*GetLikeListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoInteract_SetSave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSaveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoInteractServer).SetSave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoInteract_SetSave_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoInteractServer).SetSave(ctx, req.(*SetSaveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoInteract_GetSaveList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSaveListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoInteractServer).GetSaveList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoInteract_GetSaveList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoInteractServer).GetSaveList(ctx, req.(*GetSaveListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoInteract_PublishComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishCommentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoInteractServer).PublishComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoInteract_PublishComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoInteractServer).PublishComment(ctx, req.(*PublishCommentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoInteract_DeleteComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCommentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoInteractServer).DeleteComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoInteract_DeleteComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoInteractServer).DeleteComment(ctx, req.(*DeleteCommentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoInteract_GetCommentsList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCommentListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoInteractServer).GetCommentsList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoInteract_GetCommentsList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoInteractServer).GetCommentsList(ctx, req.(*GetCommentListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VideoInteract_ServiceDesc is the grpc.ServiceDesc for VideoInteract service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VideoInteract_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "v1.VideoInteract",
	HandlerType: (*VideoInteractServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetLike",
			Handler:    _VideoInteract_SetLike_Handler,
		},
		{
			MethodName: "GetLikeList",
			Handler:    _VideoInteract_GetLikeList_Handler,
		},
		{
			MethodName: "SetSave",
			Handler:    _VideoInteract_SetSave_Handler,
		},
		{
			MethodName: "GetSaveList",
			Handler:    _VideoInteract_GetSaveList_Handler,
		},
		{
			MethodName: "PublishComment",
			Handler:    _VideoInteract_PublishComment_Handler,
		},
		{
			MethodName: "DeleteComment",
			Handler:    _VideoInteract_DeleteComment_Handler,
		},
		{
			MethodName: "GetCommentsList",
			Handler:    _VideoInteract_GetCommentsList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "helloworld/v1/api.proto",
}

const (
	UserRelation_SetFollow_FullMethodName       = "/v1.UserRelation/SetFollow"
	UserRelation_GetFollowedList_FullMethodName = "/v1.UserRelation/GetFollowedList"
	UserRelation_GetFollowerList_FullMethodName = "/v1.UserRelation/GetFollowerList"
)

// UserRelationClient is the client API for UserRelation service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserRelationClient interface {
	// 关注（互动）
	SetFollow(ctx context.Context, in *SetFollowRequest, opts ...grpc.CallOption) (*SetFollowResponse, error)
	// 关注列表
	GetFollowedList(ctx context.Context, in *GetFollowedListRequest, opts ...grpc.CallOption) (*FollowedListResponse, error)
	// 粉丝列表
	GetFollowerList(ctx context.Context, in *GetFollowerListRequest, opts ...grpc.CallOption) (*FollowerListResponse, error)
}

type userRelationClient struct {
	cc grpc.ClientConnInterface
}

func NewUserRelationClient(cc grpc.ClientConnInterface) UserRelationClient {
	return &userRelationClient{cc}
}

func (c *userRelationClient) SetFollow(ctx context.Context, in *SetFollowRequest, opts ...grpc.CallOption) (*SetFollowResponse, error) {
	out := new(SetFollowResponse)
	err := c.cc.Invoke(ctx, UserRelation_SetFollow_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userRelationClient) GetFollowedList(ctx context.Context, in *GetFollowedListRequest, opts ...grpc.CallOption) (*FollowedListResponse, error) {
	out := new(FollowedListResponse)
	err := c.cc.Invoke(ctx, UserRelation_GetFollowedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userRelationClient) GetFollowerList(ctx context.Context, in *GetFollowerListRequest, opts ...grpc.CallOption) (*FollowerListResponse, error) {
	out := new(FollowerListResponse)
	err := c.cc.Invoke(ctx, UserRelation_GetFollowerList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserRelationServer is the server API for UserRelation service.
// All implementations must embed UnimplementedUserRelationServer
// for forward compatibility
type UserRelationServer interface {
	// 关注（互动）
	SetFollow(context.Context, *SetFollowRequest) (*SetFollowResponse, error)
	// 关注列表
	GetFollowedList(context.Context, *GetFollowedListRequest) (*FollowedListResponse, error)
	// 粉丝列表
	GetFollowerList(context.Context, *GetFollowerListRequest) (*FollowerListResponse, error)
	mustEmbedUnimplementedUserRelationServer()
}

// UnimplementedUserRelationServer must be embedded to have forward compatible implementations.
type UnimplementedUserRelationServer struct {
}

func (UnimplementedUserRelationServer) SetFollow(context.Context, *SetFollowRequest) (*SetFollowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetFollow not implemented")
}
func (UnimplementedUserRelationServer) GetFollowedList(context.Context, *GetFollowedListRequest) (*FollowedListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFollowedList not implemented")
}
func (UnimplementedUserRelationServer) GetFollowerList(context.Context, *GetFollowerListRequest) (*FollowerListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFollowerList not implemented")
}
func (UnimplementedUserRelationServer) mustEmbedUnimplementedUserRelationServer() {}

// UnsafeUserRelationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserRelationServer will
// result in compilation errors.
type UnsafeUserRelationServer interface {
	mustEmbedUnimplementedUserRelationServer()
}

func RegisterUserRelationServer(s grpc.ServiceRegistrar, srv UserRelationServer) {
	s.RegisterService(&UserRelation_ServiceDesc, srv)
}

func _UserRelation_SetFollow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetFollowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserRelationServer).SetFollow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserRelation_SetFollow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserRelationServer).SetFollow(ctx, req.(*SetFollowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserRelation_GetFollowedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFollowedListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserRelationServer).GetFollowedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserRelation_GetFollowedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserRelationServer).GetFollowedList(ctx, req.(*GetFollowedListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserRelation_GetFollowerList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFollowerListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserRelationServer).GetFollowerList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserRelation_GetFollowerList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserRelationServer).GetFollowerList(ctx, req.(*GetFollowerListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserRelation_ServiceDesc is the grpc.ServiceDesc for UserRelation service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserRelation_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "v1.UserRelation",
	HandlerType: (*UserRelationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetFollow",
			Handler:    _UserRelation_SetFollow_Handler,
		},
		{
			MethodName: "GetFollowedList",
			Handler:    _UserRelation_GetFollowedList_Handler,
		},
		{
			MethodName: "GetFollowerList",
			Handler:    _UserRelation_GetFollowerList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "helloworld/v1/api.proto",
}

const (
	VideoFeed_GetVideoList_FullMethodName      = "/v1.VideoFeed/GetVideoList"
	VideoFeed_GetUserVideoList_FullMethodName  = "/v1.VideoFeed/GetUserVideoList"
	VideoFeed_SearchVideoList_FullMethodName   = "/v1.VideoFeed/SearchVideoList"
	VideoFeed_ClassifyVideoList_FullMethodName = "/v1.VideoFeed/ClassifyVideoList"
	VideoFeed_GetVideoStream_FullMethodName    = "/v1.VideoFeed/GetVideoStream"
)

// VideoFeedClient is the client API for VideoFeed service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VideoFeedClient interface {
	GetVideoList(ctx context.Context, in *GetVideoListRequest, opts ...grpc.CallOption) (*VideoListResponse, error)
	GetUserVideoList(ctx context.Context, in *GetUserVideoListRequest, opts ...grpc.CallOption) (*VideoListResponse, error)
	SearchVideoList(ctx context.Context, in *SearchVideoListRequest, opts ...grpc.CallOption) (*VideoListResponse, error)
	ClassifyVideoList(ctx context.Context, in *ClassifyVideoListRequest, opts ...grpc.CallOption) (*VideoListResponse, error)
	GetVideoStream(ctx context.Context, in *GetVideoStreamRequest, opts ...grpc.CallOption) (*VideoStreamResponse, error)
}

type videoFeedClient struct {
	cc grpc.ClientConnInterface
}

func NewVideoFeedClient(cc grpc.ClientConnInterface) VideoFeedClient {
	return &videoFeedClient{cc}
}

func (c *videoFeedClient) GetVideoList(ctx context.Context, in *GetVideoListRequest, opts ...grpc.CallOption) (*VideoListResponse, error) {
	out := new(VideoListResponse)
	err := c.cc.Invoke(ctx, VideoFeed_GetVideoList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoFeedClient) GetUserVideoList(ctx context.Context, in *GetUserVideoListRequest, opts ...grpc.CallOption) (*VideoListResponse, error) {
	out := new(VideoListResponse)
	err := c.cc.Invoke(ctx, VideoFeed_GetUserVideoList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoFeedClient) SearchVideoList(ctx context.Context, in *SearchVideoListRequest, opts ...grpc.CallOption) (*VideoListResponse, error) {
	out := new(VideoListResponse)
	err := c.cc.Invoke(ctx, VideoFeed_SearchVideoList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoFeedClient) ClassifyVideoList(ctx context.Context, in *ClassifyVideoListRequest, opts ...grpc.CallOption) (*VideoListResponse, error) {
	out := new(VideoListResponse)
	err := c.cc.Invoke(ctx, VideoFeed_ClassifyVideoList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoFeedClient) GetVideoStream(ctx context.Context, in *GetVideoStreamRequest, opts ...grpc.CallOption) (*VideoStreamResponse, error) {
	out := new(VideoStreamResponse)
	err := c.cc.Invoke(ctx, VideoFeed_GetVideoStream_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VideoFeedServer is the server API for VideoFeed service.
// All implementations must embed UnimplementedVideoFeedServer
// for forward compatibility
type VideoFeedServer interface {
	GetVideoList(context.Context, *GetVideoListRequest) (*VideoListResponse, error)
	GetUserVideoList(context.Context, *GetUserVideoListRequest) (*VideoListResponse, error)
	SearchVideoList(context.Context, *SearchVideoListRequest) (*VideoListResponse, error)
	ClassifyVideoList(context.Context, *ClassifyVideoListRequest) (*VideoListResponse, error)
	GetVideoStream(context.Context, *GetVideoStreamRequest) (*VideoStreamResponse, error)
	mustEmbedUnimplementedVideoFeedServer()
}

// UnimplementedVideoFeedServer must be embedded to have forward compatible implementations.
type UnimplementedVideoFeedServer struct {
}

func (UnimplementedVideoFeedServer) GetVideoList(context.Context, *GetVideoListRequest) (*VideoListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVideoList not implemented")
}
func (UnimplementedVideoFeedServer) GetUserVideoList(context.Context, *GetUserVideoListRequest) (*VideoListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserVideoList not implemented")
}
func (UnimplementedVideoFeedServer) SearchVideoList(context.Context, *SearchVideoListRequest) (*VideoListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchVideoList not implemented")
}
func (UnimplementedVideoFeedServer) ClassifyVideoList(context.Context, *ClassifyVideoListRequest) (*VideoListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClassifyVideoList not implemented")
}
func (UnimplementedVideoFeedServer) GetVideoStream(context.Context, *GetVideoStreamRequest) (*VideoStreamResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVideoStream not implemented")
}
func (UnimplementedVideoFeedServer) mustEmbedUnimplementedVideoFeedServer() {}

// UnsafeVideoFeedServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VideoFeedServer will
// result in compilation errors.
type UnsafeVideoFeedServer interface {
	mustEmbedUnimplementedVideoFeedServer()
}

func RegisterVideoFeedServer(s grpc.ServiceRegistrar, srv VideoFeedServer) {
	s.RegisterService(&VideoFeed_ServiceDesc, srv)
}

func _VideoFeed_GetVideoList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVideoListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoFeedServer).GetVideoList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoFeed_GetVideoList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoFeedServer).GetVideoList(ctx, req.(*GetVideoListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoFeed_GetUserVideoList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserVideoListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoFeedServer).GetUserVideoList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoFeed_GetUserVideoList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoFeedServer).GetUserVideoList(ctx, req.(*GetUserVideoListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoFeed_SearchVideoList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchVideoListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoFeedServer).SearchVideoList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoFeed_SearchVideoList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoFeedServer).SearchVideoList(ctx, req.(*SearchVideoListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoFeed_ClassifyVideoList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClassifyVideoListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoFeedServer).ClassifyVideoList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoFeed_ClassifyVideoList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoFeedServer).ClassifyVideoList(ctx, req.(*ClassifyVideoListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoFeed_GetVideoStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVideoStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoFeedServer).GetVideoStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoFeed_GetVideoStream_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoFeedServer).GetVideoStream(ctx, req.(*GetVideoStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VideoFeed_ServiceDesc is the grpc.ServiceDesc for VideoFeed service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VideoFeed_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "v1.VideoFeed",
	HandlerType: (*VideoFeedServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVideoList",
			Handler:    _VideoFeed_GetVideoList_Handler,
		},
		{
			MethodName: "GetUserVideoList",
			Handler:    _VideoFeed_GetUserVideoList_Handler,
		},
		{
			MethodName: "SearchVideoList",
			Handler:    _VideoFeed_SearchVideoList_Handler,
		},
		{
			MethodName: "ClassifyVideoList",
			Handler:    _VideoFeed_ClassifyVideoList_Handler,
		},
		{
			MethodName: "GetVideoStream",
			Handler:    _VideoFeed_GetVideoStream_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "helloworld/v1/api.proto",
}
